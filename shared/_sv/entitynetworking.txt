--@author ember
--@server
--@include _katlibs2/universal/datastructure_queue.txt

if not queue then require("_katlibs2/universal/datastructure_queue.txt") end

local infiniteIndexMM
infiniteIndexMM = function(t,k)
    local newTab = {}
    setmetatable(newTab,{["__index"] = infiniteIndexMM})
    t[k] = newTab
    return newTab
end

local netcodeCBs = {}

local publicEnts = setmetatable({}, {__index = infiniteIndexMM})
-- publicEnts[key][ent]

local privateEnts = setmetatable({}, {__index = infiniteIndexMM})
-- privateEnts[steamid][key][ent]

local entLookup = {}
local entChunkQueue = queue:new()

local function doNothing() end

local function canSend(cost)
    return net.getBitsLeft() - cost > 13333
end

local function doEntChunk(key,nwEnts,recipients)
    local netActive = false

    local function netStart()
        if netActive then return end
        net.start("kl:en")
    end

    local function netSend()
        if not netActive then return end
        net.send(recipients)
    end

    local co = coroutine.wrap(function()
        for i = 1,#nwEnts do
            local nwEnt = nwEnts[i]
            while not canSend(nwEnt.cost) do
                netSend()
                coroutine.yield(false)
            end

            netStart()
            nwEnt.nwFunc()
        end

        netSend()
        coroutine.yield(true)
    end)

    local queueMessage = true
    if not entChunkQueue:any() then
        queueMessage = not co()
    end
    if not queueMessage then return end

    entChunkQueue:pushRight(co)
    hook.add("tick","kl:en_ti",function()
        while true do
            if not entChunkQueue:any() then
                hook.remove("tick","kl:en_ti")
                return
            end

            if entChunkQueue:getLeft()() then entChunkQueue:popLeft() end
        end
    end)
end

function entitynetworking.setNetcode(key,netcodeFunc,cost)
    netCodeCB = netCodeCB or doNothing
    cost = cost or 0

    netcodeCBs[key] = {
        netcodeFunc = netcodeFunc,
        cost = cost,
    }
end

function entitynetworking.broadcast(key,ents,...)
    if ents.entIndex then ents = {ents} end

    for i = 1,#ents do
        local e = ents[i]

        publicEnts[key][e] = {...}
        entLookup[e] = {
            private = false,
            key = key,
        }
    end
end

function entitynetworking.send(key,ents,players,...)
    if ents.entIndex then ents = {ents} end

    local steamIDs = {}
    for i = 1, #players do
        steamIDs[i] = players[i]:getSteamID()
    end

    for i = 1,#ents do
        local e = ents[i]

        for j = 1, #steamIDs do
            local steamID = steamIDs[j]
            privateEnts[steamID][key][e] = {...}
        end
        entLookup[e] = {
            private = true,
            key = key,
            steamIDs = steamIDs,
        }
    end
end

function entitynetworking.unregister(e)
    publicEnts[e] = nil

    local privData = privateEnts[e]
    if not privData then return end
    local players = privData.players
    for i = 1, #players do
        privateEntDirectory[players[i]:getSteamID()][e] = nil
    end
end

hook.add("ClientInitialized","kl:en_ci",function(p)
    for e,data in pairs(publicEnts) do
        networkEnt(data.nwFunc,data.cost)
    end

    local privEntList = privateEntDirectory[p:getSteamID()]
    if not privEntList then return end
    for e,_ in pairs(privEntList) do
        local data = privateEnts[e]
        networkEnt(data.nwFunc,data.cost)
    end
end)

local unregister = entitynetworking.unregister
hook.add("EntityRemoved","kl:en_er",function(e)
    unregister(e)
end)